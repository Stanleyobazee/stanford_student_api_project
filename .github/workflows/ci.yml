name: CI Pipeline

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * 1'  # Weekly security scan

env:
  DOCKER_IMAGE: stanford-students-api
  DOCKER_TAG: v1
  POSTGRES_DB: stanford_students
  POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}

permissions:
  contents: read
  security-events: write
  actions: read

jobs:
  ci:
    runs-on: self-hosted
    timeout-minutes: 30
    
    strategy:
      fail-fast: false
      matrix:
        go-version: ['1.21']
        
    env:
      GO_VERSION: ${{ matrix.go-version }}
    
    steps:
    - name: Clean workspace
      run: |
        # Clean up any previous postgres_data with permission issues
        sudo rm -rf ${{ github.workspace }}/postgres_data 2>/dev/null || true
        sudo rm -rf ${{ github.workspace }}/.migrations_applied 2>/dev/null || true
        
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ matrix.go-version }}
        cache: true
        cache-dependency-path: go.sum

    - name: Cache Go modules (corruption-resistant)
      uses: actions/cache@v4
      with:
        path: |
          /tmp/go-build-cache
          /tmp/go-mod-cache
        key: ${{ runner.os }}-go-v4-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-v4-
      continue-on-error: true

    - name: Create .env for CI
      run: |
        echo "POSTGRES_DB=${{ env.POSTGRES_DB }}" > .env
        echo "POSTGRES_USER=${{ env.POSTGRES_USER }}" >> .env
        echo "POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}" >> .env
        echo "PORT=8080" >> .env
        echo "LOG_LEVEL=info" >> .env
        chmod 600 .env

    - name: Setup Go cache environment
      run: |
        echo "ðŸ”§ Setting up Go cache environment..."
        # Use custom cache directories to avoid corruption
        export GOCACHE=/tmp/go-build-cache
        export GOMODCACHE=/tmp/go-mod-cache
        mkdir -p $GOCACHE $GOMODCACHE
        echo "GOCACHE=/tmp/go-build-cache" >> $GITHUB_ENV
        echo "GOMODCACHE=/tmp/go-mod-cache" >> $GITHUB_ENV
        echo "âœ… Cache environment configured"
        
    - name: Install dependencies
      run: make deps
      
    - name: Vulnerability scan
      run: |
        echo "ðŸ” Scanning for vulnerabilities..."
        # Install govulncheck if not present
        go install golang.org/x/vuln/cmd/govulncheck@latest
        govulncheck ./... || echo "Vulnerability scan completed with warnings"
        echo "âœ… Vulnerability scan completed"

    # - name: Format code
    #   run: |
    #     echo "ðŸ”§ Formatting Go code..."
    #     make fmt
    #     echo "âœ… Code formatting completed"

    - name: Run linting
      run: |
        # Install golangci-lint if not present
        if ! command -v golangci-lint &> /dev/null; then
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.54.2
          export PATH=$PATH:$(go env GOPATH)/bin
        fi
        make lint

    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/docker-cache
        key: ${{ runner.os }}-docker-${{ hashFiles('Dockerfile', 'go.sum') }}
        restore-keys: |
          ${{ runner.os }}-docker-

    - name: Load Docker cache
      run: |
        if [ -f "/tmp/docker-cache/image.tar.gz" ]; then
          echo "ðŸ’¾ Loading Docker cache..."
          gunzip -c /tmp/docker-cache/image.tar.gz | docker load || echo "Cache load failed, continuing..."
        else
          echo "ðŸ†† No Docker cache found"
          mkdir -p /tmp/docker-cache
        fi

    - name: Build API
      run: make build-api

    - name: Run tests with coverage
      run: |
        echo "ðŸ§ª Running unit tests with coverage..."
        go test -v -short -race -coverprofile=coverage.out ./tests/...
        go tool cover -html=coverage.out -o coverage.html
        echo "âœ… Unit tests completed"
        
    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: |
          coverage.out
          coverage.html
        retention-days: 30

    - name: Start services for health check
      timeout-minutes: 5
      run: |
        echo "ðŸš€ Starting services for health verification..."
        # Monitor resources
        echo "Available memory: $(free -h | grep Mem | awk '{print $7}')"
        echo "Available disk: $(df -h / | tail -1 | awk '{print $4}')"
        
        # Ensure clean state and handle permissions
        docker compose down || true
        # Clean postgres_data with proper permissions
        sudo rm -rf postgres_data/ 2>/dev/null || \
        docker run --rm -v $(pwd):/workspace alpine sh -c "rm -rf /workspace/postgres_data" 2>/dev/null || \
        echo "âš ï¸ Could not remove postgres_data, continuing..."
        docker system prune -f || true
        
        # Start services
        make run-api &
        echo "â³ Waiting for services to be ready..."
        sleep 15
        
    - name: Verify app and API status
      timeout-minutes: 3
      run: |
        echo "ðŸ“‹ Checking container status..."
        docker compose ps
        
        echo "ðŸ” Verifying database connectivity..."
        for i in {1..20}; do
          if docker compose exec -T postgres pg_isready -U $POSTGRES_USER -d $POSTGRES_DB 2>/dev/null; then
            echo "âœ… Database is ready and accepting connections"
            break
          fi
          echo "â³ Waiting for database... ($i/20)"
          sleep 1
        done
        
        echo "ðŸš€ Verifying API server status..."
        for i in {1..10}; do
          if curl -f -s --max-time 5 http://localhost:8080/healthcheck > /dev/null 2>&1; then
            echo "âœ… API server is responding"
            break
          fi
          echo "â³ Waiting for API server... ($i/10)"
          sleep 1
        done
        
        echo "ðŸ¥ Testing health endpoint..."
        HEALTH_RESPONSE=$(curl -s --max-time 10 http://localhost:8080/healthcheck 2>/dev/null || echo "{}")
        echo "ðŸ“Š Health check response: $HEALTH_RESPONSE"
        
        # Quick verification
        if echo "$HEALTH_RESPONSE" | grep -q '"status":"healthy"' && echo "$HEALTH_RESPONSE" | grep -q '"database":"connected"'; then
          echo "âœ… Application Status: HEALTHY"
          echo "âœ… Database Status: CONNECTED"
          echo "âœ… Service Status: VERIFIED"
        else
          echo "âš ï¸ Health check incomplete, but continuing..."
        fi
        
        echo "ðŸ§ª Quick API test..."
        if curl -f -s --max-time 5 http://localhost:8080/api/v1/students > /dev/null 2>&1; then
          echo "âœ… API endpoints: ACCESSIBLE"
        else
          echo "âš ï¸ API test incomplete, but continuing..."
        fi
        
    - name: Collect service logs
      if: failure()
      run: |
        echo "ðŸ“‹ Collecting service logs for debugging..."
        docker compose logs --tail=50 app || true
        docker compose logs --tail=20 postgres || true
        
    - name: Stop test services
      if: always()
      run: |
        echo "ðŸ›‘ Stopping test services..."
        docker compose down --remove-orphans || true
        # Clean postgres_data with proper permissions
        sudo rm -rf postgres_data/ 2>/dev/null || \
        docker run --rm -v $(pwd):/workspace alpine sh -c "rm -rf /workspace/postgres_data" 2>/dev/null || \
        echo "âš ï¸ Could not remove postgres_data, continuing..."
        docker system prune -f || true
        echo "âœ… Services stopped and cleaned up"

    - name: Docker login
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Build Docker image
      timeout-minutes: 8
      run: |
        echo "ðŸ—ï¸ Building Docker image..."
        # Monitor resources before build
        echo "Memory before build: $(free -h | grep Mem | awk '{print $7}')"
        
        # Build with security scanning
        docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} .
        docker tag ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:latest
        
        # Basic security scan
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          -v $(pwd):/workspace aquasec/trivy:latest image \
          --exit-code 0 --severity HIGH,CRITICAL \
          ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} || echo "Security scan completed with warnings"
        
        echo "âœ… Docker build completed"
        
    - name: Push Docker image
      timeout-minutes: 3
      run: |
        echo "ðŸ“¤ Pushing to Docker Hub..."
        docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}
        docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:latest
        echo "âœ… Docker push completed"

    - name: Save Docker cache
      run: |
        echo "ðŸ’¾ Saving Docker layer cache..."
        docker save ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} | gzip > /tmp/docker-cache/image.tar.gz || echo "Cache save failed, continuing..."
        echo "âœ… Cache operations completed"

    - name: Clean up
      if: always()
      run: |
        # Clean up containers and images
        docker compose down -v 2>/dev/null || true
        docker system prune -f
        # Clean up postgres_data with proper permissions
        sudo rm -rf postgres_data/ 2>/dev/null || true
        rm -rf bin/ .migrations_applied 2>/dev/null || true