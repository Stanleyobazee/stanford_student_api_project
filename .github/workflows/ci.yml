name: CI Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  DOCKER_IMAGE: stanford-students-api
  DOCKER_TAG: v1
  POSTGRES_DB: stanford_students
  POSTGRES_USER: admin_stan
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}

jobs:
  ci:
    runs-on: self-hosted
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'
        cache: true
        cache-dependency-path: go.sum

    - name: Cache Go modules (corruption-resistant)
      uses: actions/cache@v3
      with:
        path: |
          /tmp/go-build-cache
          /tmp/go-mod-cache
        key: ${{ runner.os }}-go-v4-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-v4-
      continue-on-error: true

    - name: Create .env for CI
      run: |
        echo "POSTGRES_DB=${{ env.POSTGRES_DB }}" > .env
        echo "POSTGRES_USER=${{ env.POSTGRES_USER }}" >> .env
        echo "POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}" >> .env
        echo "PORT=8080" >> .env
        echo "LOG_LEVEL=info" >> .env

    - name: Setup Go cache environment
      run: |
        echo "🔧 Setting up Go cache environment..."
        # Use custom cache directories to avoid corruption
        export GOCACHE=/tmp/go-build-cache
        export GOMODCACHE=/tmp/go-mod-cache
        mkdir -p $GOCACHE $GOMODCACHE
        echo "GOCACHE=/tmp/go-build-cache" >> $GITHUB_ENV
        echo "GOMODCACHE=/tmp/go-mod-cache" >> $GITHUB_ENV
        echo "✅ Cache environment configured"
        
    - name: Install dependencies
      run: make deps

    # - name: Format code
    #   run: |
    #     echo "🔧 Formatting Go code..."
    #     make fmt
    #     echo "✅ Code formatting completed"

    - name: Run linting
      run: |
        # Install golangci-lint if not present
        if ! command -v golangci-lint &> /dev/null; then
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.54.2
          export PATH=$PATH:$(go env GOPATH)/bin
        fi
        make lint

    - name: Cache Docker layers
      uses: actions/cache@v3
      with:
        path: /tmp/docker-cache
        key: ${{ runner.os }}-docker-${{ hashFiles('Dockerfile', 'go.sum') }}
        restore-keys: |
          ${{ runner.os }}-docker-

    - name: Load Docker cache
      run: |
        if [ -f "/tmp/docker-cache/image.tar.gz" ]; then
          echo "💾 Loading Docker cache..."
          gunzip -c /tmp/docker-cache/image.tar.gz | docker load || echo "Cache load failed, continuing..."
        else
          echo "🆆 No Docker cache found"
          mkdir -p /tmp/docker-cache
        fi

    - name: Build API
      run: make build-api

    - name: Run tests
      run: |
        echo "🧪 Running unit tests..."
        go test -v -short ./tests/...
        echo "✅ Unit tests completed"

    - name: Start services for health check
      run: |
        echo "🚀 Starting services for health verification..."
        make run-api &
        echo "⏳ Waiting for services to be ready..."
        sleep 30
        
    - name: Verify app and API status
      run: |
        echo "📋 Checking container status..."
        docker compose ps
        
        echo "🔍 Verifying database connectivity..."
        for i in {1..30}; do
          if docker compose exec -T postgres pg_isready -U $POSTGRES_USER -d $POSTGRES_DB; then
            echo "✅ Database is ready and accepting connections"
            break
          fi
          echo "⏳ Waiting for database... ($i/30)"
          sleep 2
        done
        
        echo "🚀 Verifying API server status..."
        for i in {1..15}; do
          if curl -f -s http://localhost:8080/healthcheck > /dev/null; then
            echo "✅ API server is responding"
            break
          fi
          echo "⏳ Waiting for API server... ($i/15)"
          sleep 2
        done
        
        echo "🏥 Testing health endpoint..."
        HEALTH_RESPONSE=$(curl -s http://localhost:8080/healthcheck)
        echo "📊 Health check response: $HEALTH_RESPONSE"
        
        # Verify overall status
        if echo "$HEALTH_RESPONSE" | grep -q '"status":"healthy"'; then
          echo "✅ Application status: HEALTHY"
        else
          echo "❌ Application status: UNHEALTHY"
          exit 1
        fi
        
        # Verify database connection
        if echo "$HEALTH_RESPONSE" | grep -q '"database":"connected"'; then
          echo "✅ Database status: CONNECTED"
        else
          echo "❌ Database status: DISCONNECTED"
          exit 1
        fi
        
        # Verify service identification
        if echo "$HEALTH_RESPONSE" | grep -q '"service":"stanford-uni-students-api"'; then
          echo "✅ Service identification: VERIFIED"
        else
          echo "❌ Service identification: FAILED"
          exit 1
        fi
        
        echo "🧪 Testing API endpoints..."
        # Test students endpoint
        if curl -f -s http://localhost:8080/api/v1/students > /dev/null; then
          echo "✅ Students API endpoint: ACCESSIBLE"
        else
          echo "❌ Students API endpoint: FAILED"
          exit 1
        fi
        
        echo "📊 Application Status Summary:"
        echo "  🟢 API Server: RUNNING"
        echo "  🟢 Database: CONNECTED"
        echo "  🟢 Health Check: PASSING"
        echo "  🟢 API Endpoints: ACCESSIBLE"
        echo "  🟢 Overall Status: HEALTHY"
        
    - name: Collect service logs
      if: failure()
      run: |
        echo "📋 Collecting service logs for debugging..."
        echo "=== API Logs ==="
        docker compose logs app || true
        echo "=== Database Logs ==="
        docker compose logs postgres || true
        
    - name: Stop test services
      if: always()
      run: |
        echo "🛑 Stopping test services..."
        make stop-all || true
        docker compose down || true
        echo "✅ Services stopped successfully"

    - name: Docker login
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Build Docker image
      timeout-minutes: 10
      run: |
        echo "🏗️ Building Docker image..."
        docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} .
        docker tag ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:latest
        echo "✅ Docker build completed"
        
    - name: Push Docker image
      timeout-minutes: 5
      run: |
        echo "📤 Pushing to Docker Hub..."
        docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}
        docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:latest
        echo "✅ Docker push completed"

    - name: Save Docker cache
      run: |
        echo "💾 Saving Docker layer cache..."
        docker save ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} | gzip > /tmp/docker-cache/image.tar.gz || echo "Cache save failed, continuing..."
        echo "✅ Cache operations completed"

    - name: Clean up
      if: always()
      run: |
        docker system prune -f
        make clean